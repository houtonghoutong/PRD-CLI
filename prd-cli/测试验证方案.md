# PRD-CLI 自动化测试验证方案

**制定时间**: 2025-12-22  
**目标**: 减少人工验证成本，快速发现回归问题  

---

## 🎯 测试策略

### 测试层次

```
┌─────────────────────────────────────┐
│   L1: 命令功能测试 (Unit Tests)      │  ← 快速、自动化
├─────────────────────────────────────┤
│   L2: 文件生成测试 (Integration)    │  ← 验证输出结果
├─────────────────────────────────────┤
│   L3: 流程控制测试 (E2E)            │  ← 验证工作流
├─────────────────────────────────────┤
│   L4: AI 行为测试 (Contract Tests)  │  ← 验证规则遵守
└─────────────────────────────────────┘
```

---

## 📋 测试实施方案

### 方案 1：基础自动化测试（短期实施）

使用 **Node.js + Mocha/Jest** 进行命令和文件测试

#### 1.1 安装测试框架

```bash
npm install --save-dev jest
npm install --save-dev @types/jest
```

#### 1.2 创建测试目录结构

```
prd-cli/
├── tests/
│   ├── unit/              # 单元测试
│   │   ├── baseline.test.js
│   │   ├── iteration.test.js
│   │   ├── planning.test.js
│   │   ├── version.test.js
│   │   └── review.test.js
│   ├── integration/       # 集成测试
│   │   ├── workflow-basic.test.js
│   │   ├── workflow-r0-r1.test.js
│   │   └── file-generation.test.js
│   ├── e2e/              # 端到端测试
│   │   ├── complete-flow.test.js
│   │   └── error-handling.test.js
│   ├── fixtures/         # 测试数据
│   │   └── sample-project/
│   └── helpers/          # 测试辅助函数
│       ├── setup.js
│       └── cleanup.js
└── package.json
```

#### 1.3 核心测试用例示例

**A. 命令功能测试** (`tests/unit/baseline.test.js`):

```javascript
const fs = require('fs-extra');
const path = require('path');
const { execSync } = require('child_process');

describe('Baseline Commands', () => {
  let testDir;

  beforeEach(async () => {
    // 创建临时测试目录
    testDir = path.join(__dirname, '../temp', `test-${Date.now()}`);
    await fs.ensureDir(testDir);
    
    // 初始化项目
    execSync(`node ../../bin/prd-cli.js init test-project`, {
      cwd: testDir,
      stdio: 'pipe'
    });
  });

  afterEach(async () => {
    // 清理测试目录
    await fs.remove(testDir);
  });

  test('应该创建 A0 文档', async () => {
    const projectDir = path.join(testDir, 'test-project');
    
    // 执行命令
    execSync(`node ../../../bin/prd-cli.js baseline create A0`, {
      cwd: projectDir,
      stdio: 'pipe'
    });

    // 验证文件是否生成
    const a0Path = path.join(projectDir, '01_产品基线/A0_产品基础与范围说明.md');
    expect(await fs.pathExists(a0Path)).toBe(true);

    // 验证文件内容包含必要章节
    const content = await fs.readFile(a0Path, 'utf-8');
    expect(content).toContain('# A0_产品基础与范围说明');
    expect(content).toContain('## 产品定位');
    expect(content).toContain('## 目标用户');
  });

  test('应该阻止未完成 P0 就创建 A0', async () => {
    const projectDir = path.join(testDir, 'test-project');
    
    // 删除 P0 文件模拟未完成
    const p0Path = path.join(projectDir, '00_项目总览/P0_项目基本信息.md');
    await fs.remove(p0Path);

    // 执行命令应该失败或有警告
    expect(() => {
      execSync(`node ../../../bin/prd-cli.js baseline create A0`, {
        cwd: projectDir,
        stdio: 'pipe'
      });
    }).toThrow();
  });
});
```

**B. 流程控制测试** (`tests/integration/workflow-r0-r1.test.js`):

```javascript
describe('R0-R1 Flow Control', () => {
  let testDir, projectDir;

  beforeEach(async () => {
    testDir = path.join(__dirname, '../temp', `test-${Date.now()}`);
    await fs.ensureDir(testDir);
    
    // 初始化并完成基线
    execSync(`node ../../bin/prd-cli.js init test-project`, {
      cwd: testDir,
      stdio: 'pipe'
    });
    
    projectDir = path.join(testDir, 'test-project');
    
    // 创建 A0, A1, R0
    execSync(`node ../../../bin/prd-cli.js baseline create A0`, {
      cwd: projectDir,
      stdio: 'pipe'
    });
    execSync(`node ../../../bin/prd-cli.js baseline create A1`, {
      cwd: projectDir,
      stdio: 'pipe'
    });
    execSync(`node ../../../bin/prd-cli.js baseline create R0`, {
      cwd: projectDir,
      stdio: 'pipe'
    });
  });

  afterEach(async () => {
    await fs.remove(testDir);
  });

  test('R0 完成后不应该自动创建 R1 审视', async () => {
    // R0 完成后检查是否生成了 R1_规划审视报告.md
    const r1ReviewPath = path.join(
      projectDir,
      '02_迭代记录/第01轮迭代/R1_规划审视报告.md'
    );
    
    // R1 审视报告不应该存在（因为还没创建迭代和 B1/B2）
    expect(await fs.pathExists(r1ReviewPath)).toBe(false);
  });

  test('创建迭代应该生成 R1 启动条件检查', async () => {
    // 创建迭代
    execSync(`node ../../../bin/prd-cli.js iteration new`, {
      cwd: projectDir,
      stdio: 'pipe'
    });

    // 检查是否生成 R1_规划启动条件检查.md
    const r1StartPath = path.join(
      projectDir,
      '02_迭代记录/第01轮迭代/R1_规划启动条件检查.md'
    );
    
    expect(await fs.pathExists(r1StartPath)).toBe(true);
    
    const content = await fs.readFile(r1StartPath, 'utf-8');
    expect(content).toContain('问题真实存在');
    expect(content).toContain('值得单独规划');
    expect(content).toContain('问题已理解清楚');
  });

  test('没有 B1/B2 时执行 R1 审视应该失败', async () => {
    // 创建迭代但不创建 B1/B2
    execSync(`node ../../../bin/prd-cli.js iteration new`, {
      cwd: projectDir,
      stdio: 'pipe'
    });

    // 执行 R1 审视应该失败
    expect(() => {
      execSync(`node ../../../bin/prd-cli.js review r1`, {
        cwd: projectDir,
        stdio: 'pipe'
      });
    }).toThrow(); // 应该抛出错误或返回非零退出码
  });

  test('完整流程：迭代 → B1 → B2 → R1 审视', async () => {
    // 1. 创建迭代
    execSync(`node ../../../bin/prd-cli.js iteration new`, {
      cwd: projectDir,
      stdio: 'pipe'
    });

    // 2. 创建 B1
    execSync(`node ../../../bin/prd-cli.js plan create B1`, {
      cwd: projectDir,
      stdio: 'pipe'
    });

    // 3. 创建 B2
    execSync(`node ../../../bin/prd-cli.js plan create B2`, {
      cwd: projectDir,
      stdio: 'pipe'
    });

    // 4. 执行 R1 审视
    execSync(`node ../../../bin/prd-cli.js review r1`, {
      cwd: projectDir,
      stdio: 'pipe'
    });

    // 5. 验证 R1 审视报告生成
    const r1ReviewPath = path.join(
      projectDir,
      '02_迭代记录/第01轮迭代/R1_规划审视报告.md'
    );
    
    expect(await fs.pathExists(r1ReviewPath)).toBe(true);
  });
});
```

#### 1.4 配置 package.json

```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest tests/unit",
    "test:integration": "jest tests/integration",
    "test:e2e": "jest tests/e2e",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "jest": {
    "testEnvironment": "node",
    "testMatch": [
      "**/tests/**/*.test.js"
    ],
    "coverageDirectory": "coverage",
    "coveragePathIgnorePatterns": [
      "/node_modules/",
      "/tests/"
    ]
  }
}
```

---

### 方案 2：AI 行为验证（中期实施）

由于 AI 行为难以直接测试，采用 **契约测试** 方法

#### 2.1 工作流规则检查器

创建一个规则检查脚本，验证生成的文档是否符合规则：

```javascript
// tests/helpers/workflow-checker.js

class WorkflowChecker {
  /**
   * 检查 R0 完成后的文档状态
   */
  static checkR0Completion(projectDir) {
    const issues = [];
    
    // R0 完成后不应该自动创建 R1 审视
    const r1ReviewPath = path.join(
      projectDir,
      '02_迭代记录/第01轮迭代/R1_规划审视报告.md'
    );
    
    if (fs.existsSync(r1ReviewPath)) {
      issues.push({
        severity: 'ERROR',
        rule: 'R0_NO_AUTO_R1_REVIEW',
        message: 'R0 完成后不应该自动创建 R1 审视报告'
      });
    }
    
    return issues;
  }

  /**
   * 检查 R1 启动条件是否存在
   */
  static checkR1StartCondition(projectDir, iterationNum) {
    const issues = [];
    
    const r1StartPath = path.join(
      projectDir,
      `02_迭代记录/第${String(iterationNum).padStart(2, '0')}轮迭代`,
      'R1_规划启动条件检查.md'
    );
    
    if (!fs.existsSync(r1StartPath)) {
      issues.push({
        severity: 'ERROR',
        rule: 'R1_START_REQUIRED',
        message: '创建迭代后必须生成 R1 启动条件检查文档'
      });
    } else {
      // 验证文档内容
      const content = fs.readFileSync(r1StartPath, 'utf-8');
      
      const requiredSections = [
        '问题真实存在',
        '值得单独规划',
        '问题已理解清楚'
      ];
      
      requiredSections.forEach(section => {
        if (!content.includes(section)) {
          issues.push({
            severity: 'WARNING',
            rule: 'R1_START_CONTENT',
            message: `R1 启动条件缺少必需章节: ${section}`
          });
        }
      });
    }
    
    return issues;
  }

  /**
   * 检查文档依赖关系
   */
  static checkDocumentDependencies(projectDir) {
    const issues = [];
    
    // 检查 B1 是否在迭代创建后
    // 检查 R1 审视是否在 B1/B2 后
    // ... 其他依赖检查
    
    return issues;
  }

  /**
   * 运行所有检查
   */
  static runAllChecks(projectDir) {
    const allIssues = [];
    
    allIssues.push(...this.checkR0Completion(projectDir));
    allIssues.push(...this.checkR1StartCondition(projectDir, 1));
    allIssues.push(...this.checkDocumentDependencies(projectDir));
    
    return {
      passed: allIssues.filter(i => i.severity === 'ERROR').length === 0,
      issues: allIssues,
      summary: {
        errors: allIssues.filter(i => i.severity === 'ERROR').length,
        warnings: allIssues.filter(i => i.severity === 'WARNING').length
      }
    };
  }
}

module.exports = WorkflowChecker;
```

#### 2.2 AI 行为模拟测试

```javascript
// tests/integration/ai-behavior.test.js

describe('AI Behavior Rules', () => {
  test('应该遵守 R0 结束边界规则', async () => {
    // 模拟：完成 R0
    // 检查：不应该生成后续文档
    // 验证：工作流检查器通过
    
    const result = WorkflowChecker.checkR0Completion(projectDir);
    expect(result).toHaveLength(0); // 没有违规
  });

  test('应该在创建迭代时生成 R1 启动条件', async () => {
    execSync(`node ../../../bin/prd-cli.js iteration new`, {
      cwd: projectDir
    });
    
    const result = WorkflowChecker.checkR1StartCondition(projectDir, 1);
    expect(result.filter(i => i.severity === 'ERROR')).toHaveLength(0);
  });
});
```

---

### 方案 3：快照测试（长期优化）

使用 Jest 的快照功能验证文档模板

```javascript
test('R1 启动条件模板应该匹配快照', () => {
  execSync(`node ../../../bin/prd-cli.js iteration new`, {
    cwd: projectDir
  });
  
  const r1Start = fs.readFileSync(
    path.join(projectDir, '02_迭代记录/第01轮迭代/R1_规划启动条件检查.md'),
    'utf-8'
  );
  
  expect(r1Start).toMatchSnapshot();
});
```

---

## 🚀 实施步骤

### 第一阶段（立即实施）- 基础测试

**时间**: 1-2 天

1. ✅ 安装 Jest 测试框架
2. ✅ 创建测试目录结构
3. ✅ 编写 5-10 个核心测试用例：
   - 命令基本功能
   - 文件生成验证
   - R0-R1 流程控制
4. ✅ 配置 npm test 命令
5. ✅ 运行测试，修复发现的问题

### 第二阶段（1周内）- 完善测试

**时间**: 3-5 天

1. 增加更多测试用例（覆盖所有命令）
2. 实现工作流规则检查器
3. 添加集成测试
4. 实现测试覆盖率报告

### 第三阶段（持续优化）- 自动化

**时间**: 持续

1. 配置 GitHub Actions CI/CD
2. 每次提交自动运行测试
3. 添加快照测试
4. 性能测试

---

## 📊 测试覆盖目标

| 测试类型 | 覆盖率目标 | 当前状态 |
|---------|-----------|---------|
| 命令功能 | 100% | 0% |
| 文件生成 | 90% | 0% |
| 流程控制 | 80% | 0% |
| 错误处理 | 70% | 0% |
| AI 行为 | 50% (关键路径) | 0% |

---

## 💡 快速开始

创建第一个测试：

```bash
# 1. 安装依赖
npm install --save-dev jest

# 2. 创建测试目录
mkdir -p tests/unit

# 3. 创建第一个测试文件
# 复制上面的示例代码到 tests/unit/baseline.test.js

# 4. 运行测试
npm test
```

---

## 🔍 测试金字塔原则

```
    /\
   /AI\      ← 少量 AI 行为测试（契约测试）
  /E2E \     ← 适量端到端测试（完整流程）
 /集成测试\   ← 较多集成测试（组件协作）
/单元测试___\ ← 大量单元测试（命令功能）
```

- **单元测试 70%**: 快速、稳定、易维护
- **集成测试 20%**: 验证协作
- **E2E 测试 8%**: 验证完整流程
- **AI 测试 2%**: 关键路径验证

---

**下一步行动**：

1. 我可以帮你创建第一批测试文件
2. 设置测试框架配置
3. 编写测试辅助函数

需要我现在开始创建吗？
